\documentclass[pldi,10pt,preprint]{sigplanconf-pldi16}

\begin{document}

\newcommand{\LoginSalt}[1]{{$\textrm{LoginSalt}_{#1}$}}
\newcommand{\subscr}[2]{{$\textrm{#1}_{#2}$}}

\special{papersize=8.5in,11in}
\setlength{\pdfpageheight}{\paperheight}
\setlength{\pdfpagewidth}{\paperwidth}

\conferenceinfo{CONF 'yy}{Month d--d, 20yy, City, ST, Country}
\copyrightyear{2014}
\copyrightdata{978-1-nnnn-nnnn-n/yy/mm}
% \doi{nnnnnnn.nnnnnnn}

\titlebanner{Preprint.  Please do not redistribute}        % These are ignored unless
\preprintfooter{Preprint.  Please do not redistribute}   % 'preprint' option specified.

\title{Private Collaborative Editing of Documents Over the Internet}
\subtitle{subtitle?}

%% \authorinfo{Blind Review}
%%            {Blind Review University}
%%            {BlindReview@BlindReview.edu}
\authorinfo{Benjamin Ylvisaker}
           {Colorado College}
           {ben.ylvisaker@coloradocollege.edu}

\maketitle

\begin{abstract}

Applications that give teams of people the ability to collaboratively edit documents over the Internet have become popular.
Examples include Google Docs, Evernote and Dropbox.
With few exceptions, these applications give the service providers complete access to the teams' data.
This raises multiple serious privacy concerns.

In response to related privacy concerns, end-to-end encryption has been encorporated into many Internet applications.
End-to-end encryption has been most successful with applications in which either users manage non-shared data (for example, password managers) or messaging applications with only transient, not persistent, state.

This project is the first to combine end-to-end encryption with shared, mutable state.
The key technical challenge is that the clients that belong to a team must perform the consistency protocol amongst themselves, with no central authority.
We assume that each team member will only be actively connected to the network intermittently, but also has a highly available read-only copy of the team's data.

\end{abstract}

\section{Introduction}

Privacy concerns have become important to many Internet users in recent years.
It is known that many adversaries, including powerful government and corporate organizations, thieves and vandals, have violated huge numbers of users' privacy in myriad ways.
One important tool in the struggle for privacy on the Internet is encryption, and in particular end-to-end encrypted applications.

End-to-end encryption has become common (though not universal) in applications like password management and internet messaging.
The key benefit of end-to-end encryption is that all service providers (both network and storage) only see the encrypted data.
Without breaking the encryption, lying about the application's behavior, or otherwise maliciously circumventing the system, the system provider cannot get the user's unencrypted data.
This is useful for several reasons.

Unfortunately there is a big gap in the range of applications that can currently be end-to-end encrypted.
As long as the system provider is only providing passive storage (as in password managers) or transient communication (as in messaging applications), the overall architecture is well understood.
However, in applications where a team of users collaboratively edit a document or database, the service provider also runs the consistency protocol on their servers.
In order to do this, the service provider needs access to the unecrypted data.

One gap in the end-to-end encryption landscape is applications that allow teams of users to collaboratively edit a document/database.

\subsection{Architecture}

The ManyHands protocol involves a central server, a cloud storage service for each user, and a client computer for each user.
The central server plays a small and inessential role; it is merely a convenience to help users log in from anywhere on the Internet.

We assume that the cloud storage services are highly available.
The access policy required of the storage service is trivial.
The user must be able to read and write anything in her own account's storage.
All other entities are allowed to read anything in the user's cloud storage account, but are not allowed to write anything.
World-readability is not a privacy issue, because all sensitive data is encrypted with keys that only team members have access to.

The single-writer policy is somewhat interesting.
Allowing more than one user to write to a single cloud storage location implies that the cloud storage provider has some information about the 

\section{Security and Attack Models}

In this section we discuss the core assumptions that ManHands is based on, in terms of assets it is designed to protect and threats it is designed to resist.

\subsection{Assets and Users}

The goal of the ManyHands protocol is to allow a team of users to collaboratively edit data online.
We assume that by default the team does not want anyone outside of the team to have \emph{any} access to the data.
We further assume that the users are Regular People\texttrademark, by which we mean that they have access to consumer computers and subscription services, but not dedicated servers.

The data model is described in more detail below, but ManyHands is designed to support a very general notion of data that can be thought of as a database or any kind of document.

\subsection{Threat Model}

We assume that any provider of network, storage or compute services outside the users' direct control is a potential adversary.
This may seem like an overly paranoid assumption; it is often argued that household name organizations like Google, Apple or Microsoft have a strong reputational interest in protecting their users' privacy (at least in some ways).
However, even if users trust that some service provider will not behave maliciously, there are still good reasons for a zero trust policy towards networked application service providers.

First, if an orgainization has access to a user's information, that means some subset of its employees and contractors have access.
Some of these individuals may have personal motivations to violate the privacy of users.

Second, even if an organization ``wants'' to behave completely responsibly with respect to the privacy of their users, powerful organizations, like governments, might compel it to violate that privacy.
This risk has been shown to be quite real in several cases recently, and it is far from confined to ``totalitarian'' governments.

Third, criminals can launch attacks on the service provider and exfiltrate and/or modify users' data.

Fourth, some level of trust may be reasonable in the case of household name companies, since they have a substantial investment in their own brand and do not want to be seen as bad on privacy.
However, many Internet users today place the same trust in much smaller organizations, without even thinking about it.
Clearly the less well known an organization is, the less one can rely on it behaving well to protect its own reputation.

For all these reasons, we think there is ample motivation for collaborative document editing applications that do not expose the users' data to service providers at all.

One obvious adversary is the cloud storage provider.
Because of the cryptographic protocols used, it is not possible for the cloud storage provider to extract private information about a user beyond the fact of some activity occurring.
Nor is it possible for the cloud provider to inject counterfeit information, because all stored data is signed.
If multiple users use the same cloud provider, the provider could potentially correlate the timing of writes and overall database sizes to infer which users are members of the same teams.
We consider this information relatively low risk.
However, users who are concerned about leaking even this information could arrange to use different cloud providers, or even run their own personal cloud services (obviously the latter strategy is only available to technically sophisticated users).

A cloud provider could trivially mount a denial of service attack on a user by deleting their data (or modifying it in some way, if they wanted to make the attack less obvious).
In most cases it is hard to imagine why a cloud provider would do that.
If users have reason to suspect they might come under such an attack, they could perform regular off-cloud backups, or run their own personal cloud service.

\section{Protocol}

\begin{table}
\centering
 \begin{tabular}{|l|p{6cm}|}
 \hline
 Symbol & Meaning \\
 \hline\hline
 K & \textbf{K}ey \\
 R & p\textbf{R}ivate \\
 U & p\textbf{U}blic \\
 S & \textbf{S}hared/\textbf{S}ymmertic \\
 V & signing/\textbf{V}erifying \\
 X & Diffie/Hellman key e\textbf{X}change \\
 \subscr{?}{A} & something that belongs to \textbf{A}lice \\
 H(?) & A \textbf{H}ash of something (SHA-256, unless otherwise specified) \\
 LoginSalt & Random bits generated at registration time \\
 LoginKey & A (symmetric) key derived from a user's credentials and their LoginSalt \\
 MainKey & A (symmetric) key derived from a user's private key; this is used to encrypt most of a user's private information \\
 ROOT & The root directory for ManyHands in a user's cloud account \\
 \hline
 \end{tabular}
 \caption{Cheat Sheet}
\end{table}

\subsection{Registration}

The registration process for the ManyHands protocol is fairly simple.
In order to register, a user must provide:

\begin{itemize}
\item Login credentials
\item A cloud storage account
\end{itemize}

For login credentials we assume username/password, though other authentication systems could be used.
The only change that would be required is a small modification to the derivation of the LoginKey.

The core protocol requires very little sophistication from the cloud storage system, so in principle almost any should be useable.
So far we have written implementations for DropBox, Google Drive and Microsoft OneDrive.
The user must authenticate to their cloud account independently of the core ManyHands system.
It is convenient for ManyHands implementations to cache cloud account authentication (for example, by saving a token), so that the user has to re-authenticate only infrequently.

The following items are generated during the registration process:

\begin{itemize}
\item \subscr{UVK}{A}, \subscr{RVK}{A}, A public/private key-pair for signing by Alice; the public key is Alice's core identity
\item \subscr{UXK}{A}, \subscr{RXK}{A}, A public/private key-pair for Diffie-Hellman key exchange with Alice
\item A XXX-byte-long random sequence called \subscr{LoginSalt}{A}
\end{itemize}

Using a password-based key derivation algorithm, a symmetric key called \subscr{LoginKey}{A} can be derived from Alice's credentials and \subscr{LoginSalt}{A}.
The current implementation uses PBKDF2 and XXX iterations.

Alice H(A), a hash of her username; this is Alice's identity for the purposes of the central server.
Alice checks that H(A) is not already taken on the central server.

Alice uploads the following to the central server:

\begin{itemize}
\item H(A)
\item \subscr{LoginSalt}{A}
\item \subscr{UVK}{A}
\item A link to Alice's cloud account, encrypted with \subscr{LoginKey}{A} and signed with \subscr{RVK}{A}
\item (optional) Cached authentication information (e.g. a token) for Alice's cloud account, encrypted with \subscr{LoginKey}{A} and signed with \subscr{RVK}{A}
\end{itemize}

The central server's role is strictly a convenience for logging in.
Without the central server, Alice would have to re\"{e}nter her cloud account information every time she logs in.

Note that Alice's username is hashed and the link to her cloud account is encrypted, so the central server has very little information about Alice's identity.
As detailed below, the central server plays no role in the primary parts of the protocol, like team creation and data exchange.
So the operator of the central server has no information about how users are communicating with each other.

Alice uploads her public signing key so that in the future if she wants to change any information about herself stored on the central server, she can sign the request with her private key and the server can verify the signature.

Using Diffie-Hellman key exchange, a symmetric key called \subscr{MainKey}{A} can be derived from \subscr{RXK}{A} and \subscr{UXK}{A}.

Alice uploads the following to her cloud account; all in the \subscr{ROOT}{A} directory:

\begin{itemize}
\item \subscr{LoginSalt}{A}
\item \subscr{UVK}{A}, \subscr{UXK}{A}
\item \subscr{RXK}{A}, encrypted with \subscr{LoginKey}{A} and signed with \subscr{RVK}{A}
\item \subscr{RVK}{A}, encrypted with \subscr{MainKey}{A} and signed with \subscr{RVK}{A}
\item A Teams directory and an Invites directory; both initially empty
\end{itemize}

\subsection{Login}

The login process is a follows:

\begin{enumerate}
\item Alice sends a request with H(A) to the central server
\item If the server recognizes H(A), it responds with:
  \begin{itemize}
  \item \subscr{LoginSalt}{A}
  \item The encrypted link to Alice's cloud account
  \end{itemize}
\item Alice derives \subscr{LoginKey}{A} and decrypts the link to her cloud account
\item Alice authenticates to her cloud account, possibly using cached credentials from the central server
\item Alice downloads her keys from her cloud account
\item Alice decrypts \subscr{RXK}{A} with \subscr{LoginKey}{A}
\item Alice derives \subscr{MainKey}{A} and decrypts \subscr{RVK}{A}
\item Alice verifies the link, \subscr{RXK}{A} and \subscr{RVK}{A} with \subscr{RVK}{A}
\end{enumerate}

Alice is now logged in and she can perform whatever protocol actions she chooses.

\subsection{Team Creation}

To create a team, Alice must generate:

\begin{itemize}
\item \subscr{TID}{TA}, A random team identifier that is unique to Alice \emph{and} team T
\item \subscr{UVK}{T}, \subscr{RVK}{T}, A public/private key-pair for signing by team T; the public key is the team's core identity
\item \subscr{UXK}{T}, \subscr{RXK}{T}, A public/private key-pair for Diffie-Hellman key exchange with team T
\item \subscr{DB}{T}, A database that is initialized with at least the necessary information about Alice as a teammate
\end{itemize}

Alice uploads the team information to \subscr{ROOT}{A}\slash Teams\slash \subscr{TID}{TA}.
Notice that the central server is not involved with team creation at all.

\subsection{Teammate Invitation}

Teammates can be added to teams by an existing teammate inviting a new user.
The invitation process is fairly invovled.
It is designed to leak as little information as possible about team and teammate identities.
The process could be streamlined by involving a central server of some sort to act as an invitation broker.
Such an invitation broker would naturally have the opportunity to gain information about teams.

There are 4 major steps in the invitation process, which we call opening the invitation, responding to the invitation, completing the invitation, and joining the team.
The first and third are performed by Alice, and the second and fourth are performed by Bob.

\subsubsection{Opening an Invitation}

To open an invitation of Bob to team T, Alice does the following:

\begin{enumerate}
\item Invent a unique number \subscr{N}{1}
\item Make a file with something about Bob's identity and T
\item Encrypt the file with \subscr{MainKey}{A} and sign with \subscr{RVK}{A}
\item Upload the encrypted file to \subscr{ROOT}{A}\slash Invites\slash \subscr{N}{1}\slash step1
\item Send to Bob the following:
  \begin{itemize}
  \item A link to Alice's cloud account
  \item \subscr{N}{1}
  \end{itemize}
\end{enumerate}

The ManyHands protocol does not specify how Alice sends this information to Bob.
She could put it in an email or text message or whatever.
If an adversary intercepts this information, they will learn that Alice plans to invite Bob to join a team, but no more.
Of course, Alice is free to send along additional information explaining to Bob what team he is being invited to.

\subsubsection{Responding to an Invitation}

If Bob decides to accept Alice's invitation, he does the following:

\begin{enumerate}
\item Invent a unique team identifier \subscr{TID}{TB}
\item Invent a unique number \subscr{N}{2}
\item Download \subscr{UXK}{A}
\item Derive \subscr{SK}{AB}, using \subscr{UXK}{A} and \subscr{RXK}{B}
\item Make a file with \subscr{TID}{TB} and \subscr{N}{1}
\item Encrypt the file with \subscr{SK}{AB}
\item Upload the encrypted file to \subscr{ROOT}{B}\slash Invites\slash \subscr{N}{2}
\item Send to Alice the following:
  \begin{itemize}
  \item A link to Bob's cloud account
  \item \subscr{N}{2}
  \end{itemize}
\end{enumerate}

Just like the first step, Bob can send the information back to Alice using any method.

\subsubsection{Completing an Invitation}

Alice does the following to add Bob to the team:

\begin{enumerate}
\item Download \subscr{UXK}{B} and \subscr{UVK}{B}
\item Derive \subscr{SK}{AB}, using \subscr{UXK}{B} and \subscr{RXK}{A}
\item Download \subscr{ROOT}{B}\slash Invites\slash \subscr{N}{2}
\item Decrypt the file with \subscr{SK}{AB} and verify signature with \subscr{UVK}{B} (now Alice has \subscr{TID}{TB} and \subscr{N}{1})
\item Download \subscr{ROOT}{A}\slash Invites\slash \subscr{N}{1}\slash step1
\item Decrypt the file with \subscr{MainKey}{A} and verify signature with \subscr{UVK}{A} (now Alice has her own information about Bob's identity and the team T)
\item Invent a unique ID for bob in T: \subscr{UID}{BT}
\item Add information about Bob to team T's database, including at least: (more information about the database update protocol below)
  \begin{itemize}
  \item \subscr{UID}{BT}
  \item A link to Bob's cloud account
  \item \subscr{UVK}{B}
  \item \subscr{TID}{TB}
  \end{itemize}
\item Make a file with the following
  \begin{itemize}
  \item \subscr{TID}{TA}
  \item \subscr{UID}{BT}
  \item \subscr{RVK}{T}
  \item \subscr{RXK}{T}
  \item \subscr{N}{2}
  \end{itemize}
\item Encrypt the file with \subscr{SK}{AB} and sign it with \subscr{RVK}{A}
\item Upload the encrypted file to \subscr{ROOT}{A}\slash Invites\slash \subscr{N}{1}\slash step3
\end{enumerate}

\subsubsection{Joining a Team}

Finally, Bob adds the team's information to his own cloud account.
If Alice's cloud provider supports it, Bob's client can automatically monitor \subscr{ROOT}{A}\slash Invites\slash \subscr{N}{1}\slash step3 for changes, so that Bob does not have to manually invoke this step.

\begin{enumerate}
\item Download \subscr{UXK}{A}, \subscr{UVK}{A}
\item Derive \subscr{SK}{AB}, using \subscr{UXK}{B} and \subscr{RXK}{A}
\item Download \subscr{ROOT}{A}\slash Invites\slash \subscr{N}{1}\slash step3
\item Decrypt the file with \subscr{SK}{AB} and verify signature with \subscr{UVK}{A} (now Bob has his own UID for T, Alice's TID for T, T's private keys and \subscr{N}{2})
\item Download team database from \subscr{ROOT}{A}\slash Teams\slash \subscr{TID}{TA}\slash Data
\item Derive \subscr{SK}{T}, using \subscr{UXK}{T} and \subscr{RXK}{T}
\item Decrypt database with \subscr{SK}{T} and verify signature with \subscr{RVK}{A}
\item Re\"{e}ncrypt database with \subscr{SK}{T} and sign with \subscr{RVK}{B}
\item Upload database to \subscr{ROOT}{B}\slash Teams\slash \subscr{TID}{TB}\slash Data
\end{enumerate}

Now Bob is a member of team T.

\section{Distributed Database Consistency Protocol}

The distributed database consistency protocol is part of the ManyHands protocol.
It is such an important piece, though, we decided to give it its own section.

\end{document}

Alvarado Dodds Kuenning Libeskind-Hadas
