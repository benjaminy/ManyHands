%
% Top Matter
%

\documentclass[runningheads]{llncs}

% \usepackage{ wasysym }
% \usepackage{ amssymb }

\begin{document}


\title{Scalable Causal Consistency for Secure Decentralized Collaborative Editing}
\titlerunning{Consistency for Decentralized Collaborative Editing}

% \author{Benjamin Ylvisaker\inst{1}\orcidID{0000-0002-8608-7404} \and
% Beau Carlborg\inst{1}\orcidID{}}
\author{Benjamin Ylvisaker\orcidID{0000-0002-8608-7404} \and Daniel Barnes \and Mataan Peer}
\authorrunning{B. Ylvisaker}

\institute{Colorado College, Colorado Springs, CO 80905, USA
  \email{bylvisaker@coloradocollege.edu}}

\maketitle

\begin{abstract}

Secure \emph{messaging} protocols and apps (Signal, Off-the-Record, WhatsApp, Telegram, etc.) have achieved substantial mainstream adoption.
Unfortunately, the same cannot be said of \emph{collaborative editing}, where trust-the-service-provider protocols are still used by all of the most popular applications.

One architectural approach that might help spur wider adoption of secure collaborative editing is decentralization.
However, centralization is quite useful in terms of usability and efficiency.
In particular, decentralization makes it harder for teams to agree on a consistent view of their shared document{\slash}database.

In this paper we evaluate a new tweak on an old idea: causal consistency.
Causal consistency gives decentralized teams a way to agree on the happens-before relation among their concurrent edits.
This partial order is not itself a complete conflict reconciliation strategy, but it is a useful ingredient thereof.

It is well known that the per-edit overhead to implement causal consistency scales linearly with team size in the worst case.
This overhead puts a severe pratical limit on team size.
Several researchers have explored trade-offs that gain efficiency at the expense of accuracy.

In this paper we propose a new implementation that makes a different trade-off.
The per-edit overhead in our protocol scales sub-linearly with team size as long as the degree of edit concurrency is low.
The overhead degrades reasonably gracefully back to the known worst case as edit concurrency increases.
This trade-off is unlikely to be compelling in high-performance data center applications (the focus of much of the existing research on causal consistency), because there the degree of edit concurrency is likely to be high.
However, 

We observe that in many team collaborative editing contexts, the degree of edit concurrency is usually quite low.


\keywords{Secure group messaging  \and Collaborative editing \and Cloud storage.}
\end{abstract}

\section{Introduction}

Collaborative editing applications for teams -- like Slack, Trello and Google Docs -- have become important tools for huge numbers of people in a wide range of work and social contexts.
From a privacy perspective these applications are problematic.
All popular team collaborative editing (TCE) applications use trust-the-service-provider architectures.
That is, clients send their edits to a central service to be integrated into a shared document{\slash}database and stored.

Malicious service providers can trivially violate teams' privacy.
Assuming maliciousness on the part of service providers is a paranoia step too far for some people.
But even if we assume no such maliciousness, recent experience has demonstrated fundamental problems with this architecture.
Poor operational security has resulted in data exfiltrations to criminals and intelligence organizations.
Misbehaving \emph{individuals} in organizations have violated data privacy in a variety of creative ways.
Governments and courts have applied \emph{legal} pressure on service providers and \emph{blocked{\slash}shut down} services that use encryption to protect user privacy.

In response to these privacy and security problems, many regular internet users have adopted more secure systems like end-to-end encrypted messaging networks and password managers.
Unfortunately, for some reason there does not seem to be a similar proliferation of secure collaborative editing applications.
There have been research projects that demonstrated the possibility of secure collaborative editing [cite Sproc, TRVE Data], but these ideas do not seem to have been taken up by industry or the open source community.

We believe that one important reason for this absence of secure TCE systems is that running a TCE service is substantially more expensive 

In an effort to enable TCE applications without any reliance on a central service, we are exploring distributed approaches to collaborative editing.
Though the

For these reasons, we are exploring decentralized

\section{Concurrent Edit Reconciliation}

In all collaboration applications that allow concurrent editing, a major question is how to combine potentially conflicting edits.
Several major strategies have emerged over the many years of experience with replicated data systems.
To name a few:
Systems like git expect users to be heavily involved with decisions about when and how to merge concurrent edits, and how to deal with conflicts.
Many popular applications like Google Docs use some flavor of operational transformations (OT) or conflict-free replicated data types (CRDTs) to emphasize automatic merging of concurrent edits, even when it might seem that there is a conflict.
Blockchain systems like Bitcoin and Ethereum use proof-of-work or proof-of-stake protocols to get non-cooperative groups to come to concensus on a single chain of edits.

We mention this wide range of concurrent edit reconciliation approaches to suggest that there is likely not a single approach that is best in all applications.
Our aim in this paper is not to take a strong position on, for example, automatic merging versus defferring to explicit user intervention to resolve conflicts.
Rather, we observe that one benefit of centralized systems is that they make it easy for teams to agree on a reasonable order of edits (i.e. the order in which they were received by the central service).
This order is not a complete reconciliation strategy, but it is a useful ingredient.

Decentralized systems do not provide an obvious way to establish such an order

\section{High Latency Cloud Storage}

The other important constraint for our approach to consistency is that we are assuming high latency and potentially intermittent connectivity between teammates.
This means that we should minimize the number of roucd-trips in the reconciliation protocol.

So we settled on sending a matrix clocks that encode partial edit ordering and acknowledgments.

\section{Causal Consistency and Matrix Clocks}

Causal consistency is a topic that has been researched extensively.
A large majority of that reesearch has been done in the context of high concurrency data center infrastructure.


\section{Matrix Clock Compression for Team Size Scalability}

Classical matrix clock (MC) timestamps scale quadratically with team size.
As mentioned previously, this would put a quite low practical limit on team size for TCE applications that send a timestamp with every edit.
We explore a compression of MC timestamps that is effective with the volume of concurrent editing within a team is low.
The core observation is a simple one: when edit concurrency is low there is a large amount of redundancy between timestamps.
However, some care must be taken: if clients handled naive matrix timestamps locally and then used conventional compression techniques for transmission, the size of edits could be small, but the amount of work per edit would still scale quadratically.

This compression relies on the following two observations:

\begin{itemize}
  \item Individual vector clock timestamps can be implemented as sets of references to only the specific edits that a teammate believes to be the most recent.
    The referred-to edits transitively imply the missing parts of the timestamp.
  \item If the volume of concurrent editing is low, then many users will have the same view of the current time.
    This means that we can compress.
    The remaining challenge is efficiently representing sets of teammates.
\end{itemize}

\section{Experimental Validation}

We wrote a simple simulator that builds teams and generates edit traces with varying concurrency distributions.

\section{}

%% \bibliographystyle{splncs04}
%% \bibliography{./uws.bib}


Cheaper Matrix Clocks - Frederic Ruget
Exploiting Write Semantics in Implementing Partially Replicated Causal Objects - Michel Raynal, Mustaque Ahamad
Efficient Solutions to the Replicated Log and Dictionary Problems - Gene T.J. Wuu, Arthur J. Bernstein

\end{document}
