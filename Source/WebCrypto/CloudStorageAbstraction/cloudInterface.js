// Following two functions have been adopted from:
// http://stackoverflow.com/a/12965194/2946480

longToByteArray = function(/*long*/long) {
    // we want to represent the input as a 8-bytes array
    var byteArray = [0, 0, 0, 0, 0, 0, 0, 0];

    for ( var index = 0; index < byteArray.length; index ++ ) {
        var byte = long & 0xff;
        byteArray [ index ] = byte;
        long = (long - byte) / 256 ;
    }

    return byteArray;
};

byteArrayToLong = function(/*byte[]*/byteArray) {
    var value = 0;
    for ( var i = byteArray.length - 1; i >= 0; i--) {
        value = (value * 256) + byteArray[i];
    }

    return value;
};

//TODO: bring those back soon
//var encoding = 'utf-8';
//var [ encode, decode ] = encodeDecodeFunctions( encoding );

// This function encodes an ASCII string into a byte array
function encode(string) {
    var bytes = [];
    for (var i = 0; i < string.length; ++i) {
        bytes.push(string.charCodeAt(i));
    }
    return bytes;
}

// this function decodes an ASCII string from a byte array
function decode(bytes) {
    var string = "";
    for (var i = 0; i < bytes.length; ++i) {
        string += String.fromCharCode(bytes[i]);
    }
    return string;
}

// Interface which requires a given object to be convertible to and from byte arrays
var Bytable = function() {
    this.toByteArray = function () {
        throw new AbstractMethodCallError(null, "Bytable");
    }
};
Bytable.fromByteArray = function(byteArray) {
    throw new AbstractMethodCallError(null, "Bytable");
};

// since a string is the most typical accessData type, we provide a
// bytable string class
// Parameter thing is anything convertible to a string (Mozilla Documentation)
var BytableString = function(string) {
    this.string = string;
    this.toByteArray = function() {
        return encode(this.string);
    };
    this.toString = function () {
        return this.string;
    }
};
BytableString.fromByteArray = function(byteArray) {
    return new BytableString(decode(byteArray));
};


// Handle to a shared resource; contains all the data needed to retrieve a shared
// resource from the clouds storage.
// Parameters:
//  cloudStorage: the constructingFunction to create an instance of a given cloud
//              storage (ie. in the "new" statement - e.g. new CloudStorageType())
//  accessData: date generated by the cloud storage class, that when passed to
//              retrieveSharedFile() return the shared file (usually the link for the
//              shared resource). Needs to be of type Bytable
//  path: path to the file in user's cloud.
var SharedFile = function(cloudStorage, accessData, path) {
    // checking if the received parameters are just a byte array, or
    // cloudStorage name and accessData

    // if we received just one parameter, we need to derive cloudStorage and accessData from
    // the first parameter which is a byte array
    if (typeof accessData == 'undefined') {
        var bytes = cloudStorage;
        var lengthOfCloudName = byteArrayToLong(bytes.slice(0,8));
        cloudStorage = cloudStorages[decode(bytes.slice(8,8+lengthOfCloudName))];
        var lengthOfLink = byteArrayToLong(bytes.slice(8+lengthOfCloudName,16+lengthOfCloudName));
        path = decode(bytes.slice(16+lengthOfCloudName,16+lengthOfCloudName+lengthOfLink));
        accessData = cloudStorage.sharedDataAccessType.fromByteArray(bytes.slice(16+lengthOfCloudName+lengthOfLink));
    }

    this.cloudStorage = cloudStorage;
    this.shareMethod = cloudStorage.retrieveSharedFile;
    this.accessData = accessData;
    this.path = path;

    /// this function retrieves the data stored in a shared file and returns it as a promise
    this.retrieve = function () {
        return this.shareMethod(this.accessData);
    };

    /// creates a byte array which then can be send to a different user, and reconstructed
    /// using the SharedFile() constructing function
    this.encode = function () {
        var cloudName = findCloudStorageName(this.cloudStorage);
        return (longToByteArray(cloudName.length)).concat(
        (encode(cloudName))).concat(longToByteArray(this.path.length)).
        concat(encode(this.path)).concat((accessData.toByteArray()));
    };
};

var CloudStorage = function() {
// Abstraction class for different providers of cloud
    // All of the following methods are meant to return promise objects instead of
    // relying on callback functions.

    /// this function downloads the file at a specified URL and returns a promise
    /// object with byte array containing the content of the file
    this.downloadFile = function (downloadUrl) {
        throw new AbstractMethodCallError(null, "CloudStorage");
    };

    /// this function downloads a file and then returns a promise with its contents as
    /// a string
    this.downloadTextFile = function (downloadUrl) {
        return this.downloadFile(downloadUrl).then(function(fileContents){
            return Promise.resolve(decode(fileContents));
        });
    };

    /// this function uploads a file to a specified url within the cloud. File is created
    /// out of binary data found in fileContents
    this.uploadFile = function (fileContents, url) {
        throw new AbstractMethodCallError(null, "CloudStorage");
    };

    /// this function uploads a file to a specified url within the cloud. File is created
    /// out of a string
    this.uploadTextFile = function (fileContents, url) {
        return this.uploadFile(encode(fileContents), url).then(function(result) {
            return Promise.resolve(result);
        });
    };

    /// this function should be used before any other call in CloudStorage object - its
    /// purpose is to log in to the cloud storage provider
    /// Parameters: If credentials are needed, they should be passed in credentials parameter
    this.authenticate = function (credentials) {
        throw new AbstractMethodCallError(null, "CloudStorage");
    };

    /// this function is used to create a handle for a file in the cloud storage
    /// this handle can then be shared. The returned value is a promise object
    /// with the handle (SharedFile object)
    this.shareFile = function (sharedFileUrl) {
        throw new AbstractMethodCallError(null, "CloudStorage");
    };

    /// this function is used to remove a file at a specified path. Returned is a promise
    /// object, which is resolved once the file is removed
    this.removeFile = function (filePath) {
        throw new AbstractMethodCallError(null, "CloudStorage");
    };
};

// static methods of CloudStorage:
// This method retrieves a file from accessData object previously created by
// CloudStorage.shareFile(). Returns a promise object
CloudStorage.retrieveSharedFile = function (accessData) {
    throw new AbstractMethodCallError(null, "CloudStorage");
};

// static properties of CloudStorage:
CloudStorage.sharedDataAccessType = null; // indicates the type of accessData
                                          // in SharedFile constructor


// An associative array containg names of clouds and their constructing functions
var cloudStorages = {};

// this function returns a key corresponding to a value in cloudStorages array
// cloudStorageConstructingFunction is the function used to create a new instance
// of a given cloud (in other words, used like this: new CloudStorageType();)
function findCloudStorageName(cloudStorageConstructingFunction) {
    for (var key in cloudStorages) {
        if (cloudStorages[key] == cloudStorageConstructingFunction)
            return key;
    }
    throw new NotFoundError("Requested CloudStorage could not be found");
}